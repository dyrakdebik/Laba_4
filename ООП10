#include <io.h>       // для функции _setmode
#include <fcntl.h>    // для константы _O_U16TEXT
#include <iostream>   // для функций ввода/вывода
#include <cstdlib>    // для функции random
#include <ctime> 
#include <string>
#define _CRT_SECURE_NO_WARNINGS 1
using namespace std;
////////////////////////////////  Для задания №2/5  ///////////////////////////////////////////////////
class publication
{
private:
	wstring title; // название издания
	float price;   // цена экземпляра издания
public:
	virtual void getdata()
	{
		// Для получения названия издания используем функцию getline, чтобы
		// можно было вводить названия из нескольких слов (с пробелами), хотя
		// задание этого и не требует.

		// При вводе нескольких объектов функция getline при вводе второго
		// объекта будет использоваться после оператора извлечения (>>)
		// числа из потока wcin предыдущего объекта. При этом после оператора
		// извлечения (>>) в потоке wcin останется символ L'\n', из-за чего
		// не получится ввести название издания для второго объекта.
		// Чтобы избежать этой ситуации, используем функцию ws, которая удаляет
		// ведущие пробельные символы из входящего потока wcin.

		wcout << L"\n введите название издания: "; getline(ws(wcin), title);
		wcout << L" введите цену экземпляра издания: "; wcin >> price;
	}
	virtual void putdata() const
	{
		wcout << L"\n название издания: " << title;
		wcout << L"\n цена экземпляра издания: " << price << endl;
	}
	virtual bool isOversize() const = 0; // чистый виртуальный метод
};

// класс, представляющий бумажную книгу (производный от класса, представляющего издание)
class book : public publication
{
private:
	int pages; // количество страниц в книге
public:
	void getdata()
	{
		publication::getdata();
		wcout << L" введите количество страниц в книге: "; wcin >> pages;
	}
	void putdata() const
	{
		publication::putdata();
		wcout << L" количество страниц в книге: " << pages << endl;
	}
	// с помощью этого метода можно определить, не слишком ли большой размер у книги
	bool isOversize() const
	{
		if (pages > 800) // размер книги считается слишком большим, если количество
			return true; // страниц в ней больше 800
		else
			return false;
	}
};

// класс, представляющий аудиокнигу (производный от класса, представляющего издание)
class tape : public publication
{
private:
	float playing_time; // время проигрывания аудиокниги в минутах
public:
	void getdata()
	{
		publication::getdata();
		wcout << L" введите время проигрывания аудиокниги в минутах: "; wcin >> playing_time;
	}
	void putdata() const
	{
		publication::putdata();
		wcout << L" время проигрывания аудиокниги в минутах: " << playing_time << endl;
	}
	// с помощью этого метода можно определить, не слишком ли большая длительность у аудиокниги
	bool isOversize() const
	{
		if (playing_time > 90) // длительность аудиокниги считается слишком большой, если
			return true;       // время ее проигрывания больше 90 минут,
		else                   // то есть она занимает больше двух 45-минутных аудиокассет
			return false;
	}
};
////////////////////////////////  Для задания №3  ///////////////////////////////////////////////////
class Distance // длина в английской системе
{
private:
	int feet;     // футы (1 фут = 12 дюймов)
	float inches; // дюймы
public:
	// конструктор без аргументов
	Distance() : feet(0), inches(0.0)
	{ }
	// конструктор с одним аргументом (конвертирует float в Distance)
	Distance(float fltfeet)
	{
		feet = static_cast<int>(fltfeet); // футы — это целая часть fltfeet,
		inches = 12 * (fltfeet - feet);   // остальное — это дюймы
	}
	// конструктор с двумя аргументами
	Distance(int ft, float in) : feet(ft), inches(in)
	{ }
	void showdist() const // вывод полей на экран
	{
		wcout << feet << L"\'-" << inches << L'\"';
	}
	// перемножение двух длин (перегрузка бинарной операции умножения)
	// (дружественная функция, не является членом класса)
	friend float operator* (Distance, Distance); // прототип
};

// перемножение двух длин (перегрузка бинарной операции умножения)
float operator* (Distance d1, Distance d2)
{
	return (d1.feet + d1.inches / 12) * (d2.feet + d2.inches / 12);
}
////////////////////////////////  Для задания №4  ///////////////////////////////////////////////////
class Array // класс, моделирующий обычный массив целых чисел в C++
{
private:
	int* ptr; // указатель на содержимое массива
	int size; // количество элементов в массиве
public:
	Array() : ptr(0), size(0)     // конструктор без аргументов
	{ }
	Array(int s)                  // конструктор с одним аргументом
	{
		size = s;                 // аргументом задается количество элементов в массиве
		ptr = new int[s];         // выделим память под наш массив
	}
	Array(Array& arr)             // перегруженный копирующий конструктор
	{
		size = arr.size;          // копируем количество элементов присваиваемого массива
		ptr = new int[size];      // выделим память под новый массив
		for (int i = 0; i < size; i++)   // скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i); // в наш новый массив поэлементно
	}
	~Array()                      // деструктор
	{
		delete[] ptr;
	}
	int& operator[] (int j)       // перегруженный оператор обращения к элементу массива
	{
		return *(ptr + j);
	}
	Array& operator= (Array& arr) // перегруженный оператор присваивания
	{
		// проверка на присваивание самому себе
		if (this == &arr) return *this;

		delete[] ptr;             // освободим память, выделенную ранее под массив в конструкторе
								  // массива, которому присваиваем заданный массив
		size = arr.size;          // копируем количество элементов присваиваемого массива
		ptr = new int[size];      // выделим память под новый массив
		for (int i = 0; i < size; i++)   // скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i); // в наш новый массив поэлементно
		return *this;             // возвращаем текущий объект
	}
	void display()                // вывод элементов массива на экран
	{
		for (int i = 0; i < size; i++)
			wcout << *(ptr + i) << L' ';
	}
};
////////////////////////////////  Для задания №6  ///////////////////////////////////////////////////
class bMoney // класс, представляющий денежную сумму в долларах и центах
{
private:
	long double sum; // денежная сумма в долларах и центах
public:
	bMoney() // конструктор без параметров
	{
		sum = 0.0L;
	}
	// конструктор с одним параметром (преобразование из long double в bMoney)
	// (с помощью служебного слова explicit делаем возможным использование
	// конструктора только в виде конструктора, а не для неявных преобразований)
	explicit bMoney(long double n) : sum(n)
	{ }
	bMoney(const wchar_t s[]) // конструктор с одним параметром (денежная строка)
	{
		mstold(s);
	}
	// метод преобразует денежную строку в число типа long double
	long double mstold(const wchar_t[]); // прототип
	// метод преобразует число типа long double (sum) в денежную строку и
	// возвращает эту строку через первый параметр
	void ldtoms(wchar_t[]); // прототип
	// метод для получения денежной строки от пользователя с клавиатуры
	// и сохранения ее в поле sum класса
	void getmoney()
	{
		wchar_t tms[80]; // для строки с денежной суммой
		wcout << L"Введите денежную сумму (пример: '$1,234,567.99'):\n";
		wcin >> tms; // получаем денежную строку
		mstold(tms); // преобразуем денежную строку в long double и сохраняем в sum
	}
	// метод для вывода поля sum класса на экран в виде денежной строки
	void putmoney()
	{
		wchar_t tms[80]; // для строки с денежной суммой
		ldtoms(tms);     // преобразуем поле sum класса (long double) в денежную строку
		wcout << tms;    // выводим денежную строку на экран
	}
	// операция сложения двух объектов класса
	bMoney operator+ (bMoney m) const
		// используем конструктор с одним параметром для преобразования long double в bMoney
	{
		return bMoney(sum + m.sum);
	}
	// операция нахождения разности двух объектов класса
	bMoney operator- (bMoney m) const
	{
		return bMoney(sum - m.sum);
	}
	// операция нахождения произведения объекта класса и числа типа long double
	bMoney operator* (long double n) const
	{
		return bMoney(sum * n);
	}
	// операция нахождения частного от деления объекта класса на другой объект класса
	long double operator/ (bMoney m) const
	{
		return sum / m.sum;
	}
	// операция нахождения частного от деления объекта класса на число типа long double
	bMoney operator/ (long double n) const
	{
		return bMoney(sum / n);
	}
	// дружественный для класса bMoney оператор для обработки выражений вида long double * bMoney
	friend bMoney operator* (long double, bMoney); // прототип
	// дружественный для класса bMoney оператор для обработки выражений вида long double / bMoney
	friend long double operator/ (long double, bMoney); // прототип
	// дружественная для класса bMoney функция для округления денежной строки до долларов
	friend bMoney round(bMoney); // прототип
};
////////////////////////////////  Для задания №8  ///////////////////////////////////////////////////
class Token // абстрактный базовый класс
			// (token — по-русски тоже «токен» — объект, выделяемый из строки с
			// арифметическим выражением в процессе ее анализа (парсинга);
			// у нас будут два вида токенов — вещественное число и арифметическая
			// операция)
{
public:
	virtual float getNumber() const = 0;     // чистые виртуальные функции
	virtual wchar_t getOperator() const = 0;
};

class Operator : public Token // класс, представляющий токен «арифметическая операция»
{
private:
	wchar_t oper; // знак арифметической операции (возможные значения: +, –, *, /)
public:
	Operator(wchar_t op) : oper(op) // конструктор с одним аргументом
	{ }
	wchar_t getOperator() const     // метод выдает знак операции
	{
		return oper;
	}
	float getNumber() const // фиктивная функция (нужна только, чтобы данный класс
	{
		return 0.0f;
	}    // не стал абстрактным, для объектов данного класса
				 // не должна вызываться)
};

class Number : public Token // класс, представляющий токен «вещественное число»
{
private:
	float fnum; // вещественное число
public:
	Number(float n) : fnum(n)       // конструктор с одним аргументом
	{ }
	float getNumber() const         // метод выдает значение вещественного числа
	{
		return fnum;
	}
	wchar_t getOperator() const // фиктивная функция (нужна только, чтобы данный класс
	{
		return L'0';
	}        // не стал абстрактным, для объектов данного класса
					 // не должна вызываться)
};

class Stack // класс, реализующий стек
{
private:
	Token* atoken[100]; // стек в виде массива указателей на токены
						// (может содержать переменные типов Operator* и Number*)
	int top;            // индекс, указывающий на вершину стека
public:
	Stack()                // конструктор без аргументов
	{
		top = 0;
	}
	void push(Token* var)  // поместить токен в стек
	{
		atoken[++top] = var;
	}
	Token* pop()           // забрать токен из стека
	{
		return atoken[top--];
	}
	int gettop() const     // получить индекс, указывающий на вершину стека
	{
		return top;
	}
	bool isNumber() const  // метод определяет, является ли токен на вершине стека
	{                      // вещественным числом (работает, только если стек не пуст)
						   // (возможность RTTI в компиляторе должна быть включена)
		Number* pNum;
		if (pNum = dynamic_cast<Number*>(atoken[top]))
			return true;
		else
			return false;
	}
};
////////////////////////////////  Для задания №9  ///////////////////////////////////////////////////
const int CPF = 5;       // для изображения на экране: длина фурлонга в столбцах
const int maxHorses = 7; // максимально возможное количество лошадей

class track; // класс, представляющий скаковой трек
			 // (предварительное объявление класса для того, чтобы можно было
			 // его использовать в тексте программы раньше, чем он будет определен)

class comtrack; // предварительное объявление нового класса, представляющего скаковой трек

class horse // класс, представляющий бегущую лошадь
{
protected:
	const track* ptrTrack;  // скаковой трек, по которому бежит лошадь
							// (указатель на константу)
	const int horse_number; // номер лошади (константа)
	float finish_time;      // время со старта забега до пересечения линии финиша
							// (в секундах)
	float distance_run;     // длина (в фурлонгах) части дистанции, пройденной
							// на данный момент
public:
	// конструктор с двумя аргументами: номер лошади, указатель на трек
	horse(const int n, const track* ptrT) :
		horse_number(n),
		ptrTrack(ptrT),
		distance_run(0.0) // лошадь еще не стартовала
	{ }
	// деструктор
	~horse()
	{ }
	// метод для отображения лошади на экране
	void display_horse(const float elapsed_time);
};

class comhorse : public horse // новый класс, представляющий бегущую лошадь, производный от старого
{
private:
	const comtrack* ptrTrack; // скаковой трек (нового класса), по которому бежит лошадь
							  // (указатель на константу)
public:
	// конструктор с двумя аргументами: номер лошади, указатель на трек
	comhorse(const int n, const comtrack* ptrT) :
		horse(n, NULL), // NULL — означает, что не будет использоваться объект старого класса track,
		ptrTrack(ptrT)  // при этом остальные поля старого класса horse будем использовать
	{ }
	// перегруженный метод для отображения лошади на экране
	void display_horse(const float elapsed_time); // прототип
};

class track // класс, представляющий скаковой трек
{
protected:
	horse* hArray[maxHorses]; // массив указателей на объекты-лошади
	int total_horses;         // обшее количество лошадей, участвующих в забеге
	int horse_count;          // счетчик лошадей, обработанных на текущий момент времени
							  // (в каждый момент времени нужно вычислять новое положение
							  // каждой лошади и отображать эту лошадь на экране; счетчик
							  // показывает сколько лошадей уже обработано)
	const float track_length; // длина трека (в фурлонгах)
	float elapsed_time;       // время, прошедшее со старта забега (в секундах)
public:
	// конструктор с двумя аргументами: длина трека, количество лошадей, участвующих в забеге
	track(float lenT, int nH);
	~track();                    // деструктор
	void display_track();        // метод для отображения трека на экране
	void run();                  // метод для запуска забега
	float get_track_len() const; // метод для получения длины трека
};

class comtrack : public track // новый класс, представляющий скаковой трек, производный от старого
{
private:
	comhorse* hArray[maxHorses]; // массив указателей на объекты-лошади
	int horse_count;
public:
	// конструктор с двумя аргументами: длина трека, количество лошадей, участвующих в забеге
	comtrack(float lenT, int nH);
	~comtrack();                 // деструктор
	void run();                  // метод для запуска забега
	// метод display_horse класса comhorse является дружественным
	friend void comhorse::display_horse(float);
};

// метод для отображения лошади на экране
// (elapsed_time — время, прошедшее со старта забега)
void horse::display_horse(float elapsed_time)
{
	// установим курсор в нужную позицию на экране:
	// координата Х зависит от длины части дистанции пройденной лошадью на данный момент;
	// координата Y зависит от номера лошади, так как лошади отображаются по порядку сверху вниз
	set_cursor_pos(1 + int(distance_run * CPF), 2 + horse_number * 2);

	// все лошади отображаются разных цветов, цвет зависит от номера лошади
	set_color(static_cast<color>(cBLUE + horse_number));

	// вычисляем символ для отображения номера лошади
	wchar_t horse_char = L'0' + static_cast<wchar_t>(horse_number);

	// отображаем лошадь четырьмя символами:
	// пробел, закрашенный прямоугольник, номер лошади, закрашенный прямоугольник
	// (шестнадцатиричный код закрашенного прямоугольника в Юникоде — 2588)
	// (пробел нужен, чтобы стирать предыдущее местонахождение лошади)
	_putwch(L' '); _putwch(L'\x2588'); _putwch(horse_char); _putwch(L'\x2588');

	// если финиш еще не достигнут
	if (distance_run < ptrTrack->get_track_len() + 1.0 / CPF)
	{
		// случайным образом генерируем одно из трех чисел: 0 или 1 или 2
		// в случае генерации 0 лошадь остается на месте,
		// в случае генерации 1 или 2 лошадь продвигается вперед на 0,2 фурлонга
		if (rand() % 3)
			distance_run += 0.2F;
		// запоминаем в поле finish_time для текущей лошади время, прошедшее
		// со старта забега
		finish_time = elapsed_time;
	}
	else // финиш достигнут
	{
		// вывести время, прошедшее со старта забега до пересечения линии финиша,
		// на экран
		int mins = int(finish_time) / 60;
		int secs = int(finish_time) - mins * 60;
		wcout << L" Время = " << mins << ":" << secs;
	}
}

// перегруженный метод для отображения лошади на экране (для нового класса)
// (elapsed_time — время, прошедшее со старта забега)
void comhorse::display_horse(float elapsed_time)
{
	// установим курсор в нужную позицию на экране:
	// координата Х зависит от длины части дистанции пройденной лошадью на данный момент;
	// координата Y зависит от номера лошади, так как лошади отображаются по порядку сверху вниз
	set_cursor_pos(1 + int(distance_run * CPF), 2 + horse_number * 2);

	// все лошади отображаются разных цветов, цвет зависит от номера лошади
	set_color(static_cast<color>(cBLUE + horse_number));

	// вычисляем символ для отображения номера лошади
	wchar_t horse_char = L'0' + static_cast<wchar_t>(horse_number);

	// отображаем лошадь четырьмя символами:
	// пробел, закрашенный прямоугольник, номер лошади, закрашенный прямоугольник
	// (шестнадцатиричный код закрашенного прямоугольника в Юникоде — 2588)
	// (пробел нужен, чтобы стирать предыдущее местонахождение лошади)
	_putwch(L' '); _putwch(L'\x2588'); _putwch(horse_char); _putwch(L'\x2588');

	// если финиш еще не достигнут
	if (distance_run < ptrTrack->get_track_len() + 1.0 / CPF)
	{
		float speed = 0.2F; // скорость лошади по умолчанию (0.2 фурлонга за тик)

		// если лошадь прошла 1/3 или больше общей длины трека
		if (distance_run >= ptrTrack->get_track_len() / 3)
		{
			// если в гонке участвует больше одной лошади
			if (ptrTrack->total_horses > 1)
			{
				int Ld, Sc; // номера лошадей: лидера и идущей второй

				// сначала возьмем в качестве лидера и идущей второй
				// первые две лошади из массива (номера этих лошадей 0 и 1)
				if (ptrTrack->hArray[0]->distance_run < ptrTrack->hArray[1]->distance_run)
				{
					Ld = 1; Sc = 0;
				}
				else
				{
					Ld = 0; Sc = 1;
				}

				// просмотрим массив указателей на объекты-лошади, начиная с лошади под номером 2
				for (int j = 2; j < ptrTrack->total_horses; j++)
				{
					if (ptrTrack->hArray[Ld]->distance_run < ptrTrack->hArray[j]->distance_run)
					{
						Sc = Ld; Ld = j;
					}
					else if (ptrTrack->hArray[Sc]->distance_run < ptrTrack->hArray[j]->distance_run)
					{
						Sc = j;
					}
				}

				// если наша лошадь является лидером или идущей второй
				// (сравниваем не номера, а пройденные дистанции, из-за того, что несколько лошадей
				// могут идти вровень)
				if (distance_run == ptrTrack->hArray[Ld]->distance_run ||
					distance_run == ptrTrack->hArray[Sc]->distance_run)
				{
					// и расстояние между лидером и идущей второй не превышает 0.1 фурлонга
					if (ptrTrack->hArray[Ld]->distance_run - ptrTrack->hArray[Sc]->distance_run <= 0.1F)
						// временно ускорим нашу лошадь с 0.2 до 0.3 фурлонга за тик
						speed = 0.3F;

					// из-за временного увеличения скорости на треке должна остаться
					// отметка в том месте, где лошадь ускорялась; я не стал пытаться ее стереть,
					// так как посчитал это небесполезной особенностью программы (фичей)

					// в результате этого ускорения некоторые лошади могут закончить гонку,
					// немного переехав финишную прямую, так как проверка пересечения финиша
					// рассчитана на скорость 0.2 фурлонга за тик
				}
			}
		}

		// случайным образом генерируем одно из трех чисел: 0 или 1 или 2
		// в случае генерации 0 лошадь остается на месте,
		// в случае генерации 1 или 2 лошадь продвигается вперед на количество фурлонгов,
		// указанное в переменной speed
		if (rand() % 3)
			distance_run += speed;
		// запоминаем в поле finish_time для текущей лошади время, прошедшее
		// со старта забега
		finish_time = elapsed_time;
	}
	else // финиш достигнут
	{
		// вывести время, прошедшее со старта забега до пересечения линии финиша,
		// на экран
		int mins = int(finish_time) / 60;
		int secs = int(finish_time) - mins * 60;
		wcout << L" Время = " << mins << ":" << secs;
	}
}

// конструктор с двумя аргументами: длина трека, количество лошадей, участвующих в забеге
track::track(float lenT, int nH) :
	track_length(lenT), // длина трека
	total_horses(nH),   // количество лошадей, участвующих в забеге
	horse_count(0),     // на треке еще нет лошадей
	elapsed_time(0.0)   // забег еще не стартовал
{
	// инициализация консольной графики
	init_graphics();
	// количество лошадей не может быть больше указанного в константе maxHorses
	total_horses = (total_horses > maxHorses) ? maxHorses : total_horses;

	// создать объекты класса horse и заполнить массив указателей на них
	for (int j = 0; j < total_horses; j++)
		hArray[j] = new horse(horse_count++, this);

	// инициализировать генерацию случайных чисел, исходя из текущего системного времени
	time_t aTime;
	srand(static_cast<unsigned>(time(&aTime)));

	// отобразить сконструированный трек на экране
	display_track();
}

// конструктор с двумя аргументами: длина трека, количество лошадей, участвующих в забеге
// (для трека нового класса)
comtrack::comtrack(float lenT, int nH) :
	track(lenT, nH), horse_count(0)
{
	// создать объекты нового класса comhorse и заполнить массив указателей на них
	for (int j = 0; j < total_horses; j++)
		hArray[j] = new comhorse(horse_count++, this);
}

// деструктор
track::~track()
{
	// освободить память, выделенную в конструкторе под объекты-лошади
	for (int j = 0; j < total_horses; j++)
		delete hArray[j];
}

// деструктор (для трека нового класса)
comtrack::~comtrack()
{
	// освободить память, выделенную в конструкторе под объекты-лошади нового класса
	for (int j = 0; j < total_horses; j++)
		delete hArray[j];
}

// метод для отображения трека на экране
void track::display_track()
{
	// очистить экран
	clear_screen();
	// отобразить трек
	for (int f = 0; f <= track_length; f++) // цикл столбцов (фурлонгов)
		for (int r = 1; r <= total_horses * 2 + 1; r++) // цикл экранных строк (рядов)
		{
			set_cursor_pos(f * CPF + 5, r);  // установим курсор в нужное место
			if (f == 0 || f == track_length) // если это начало или конец трека
				wcout << L'\x2590';          // рисуем стартовую или финишную линию
			else                             // иначе
				wcout << L'\x2502';          // рисуем отметку очередного фурлонга
		}
}

// метод для запуска забега
void track::run()
{
	// продолжать цикл до момента нажатия любой клавиши на клавиатуре
	while (!_kbhit())
	{
		elapsed_time += 1.75; // увеличиваем время забега на 1,75 секунд
		// обрабатываем очередное движение каждой лошади
		for (int j = 0; j < total_horses; j++)
			hArray[j]->display_horse(elapsed_time);
		// функция из msoftcon.h, пауза на 500 миллисекунд
		// (то есть описанное выше увеличение времени забега elapsed_time соответствует
		// в реальном измерении интервалу времени в 500 миллисекунд)
		wait(500);
	}
	_getwch(); // принять символ с клавиатуры, возникший из-за нажатия на клавишу
	wcout << endl;
}

// метод для запуска забега (для трека нового класса)
void comtrack::run()
{
	// продолжать цикл до момента нажатия любой клавиши на клавиатуре
	while (!_kbhit())
	{
		elapsed_time += 1.75; // увеличиваем время забега на 1,75 секунд
		// обрабатываем очередное движение каждой лошади (нового класса)
		for (int j = 0; j < total_horses; j++)
			hArray[j]->display_horse(elapsed_time);
		// функция из msoftcon.h, пауза на 500 миллисекунд
		// (то есть описанное выше увеличение времени забега elapsed_time соответствует
		// в реальном измерении интервалу времени в 500 миллисекунд)
		wait(500);
	}
	_getwch(); // принять символ с клавиатуры, возникший из-за нажатия на клавишу
	wcout << endl;
}

// метод для получения длины трека
float track::get_track_len() const
{
	return track_length;
}

/// ////////////////////////////////////////////////////////////////////////////
int main() {
	setlocale(0, "");
	int zadanie;
	cout << "Введите номер задания - ";
	cin >> zadanie;
	if (zadanie == 1) {
		
	}
	else if (zadanie == 2) {
		publication* pubPtr[100]; // массив указателей на объекты класса publication
		int n = 0;                // количество действительно занятых элементов массива
		wchar_t choice;           // символ, отражающий выбор пользователя

		// пользователь в цикле вводит данные изданий
		do {
			wcout << L"Вводим бумажную или аудиокнигу? (б/а): "; wcin >> choice;
			if (choice == L'б')       // поместить новый объект-бумажную книгу
				pubPtr[n] = new book; //     в массив
			else                      // поместить новый объект-аудиокассету
				pubPtr[n] = new tape; //     в массив
			wcout << L"Ввод данных издания " << n + 1 << L":";
			pubPtr[n++]->getdata();   // получим данные издания у пользователя
			wcout << L"\nВвести следующее издание? (д/н): "; wcin >> choice; wcout << endl;
		} while (choice == L'д'); // цикл выполняется, пока ответ «да»

		// выведем на экран данные введенных выше изданий
		for (int j = 0; j < n; j++)
		{
			wcout << L"Данные издания " << j + 1 << L":";
			pubPtr[j]->putdata();
		}
	}
	else if (zadanie == 3) {
		Distance dist1 = 2.5;  // (для конвертации вещественных чисел в объекты класса
		Distance dist2 = 1.25; // Distance используется конструктор с одним аргументом)
		float Wdist; // для хранения результата перемножения двух объектов класса Distance

		// заданы два интервала в английских мерах длины, покажем их на экране
		wcout << L"dist1 = "; dist1.showdist();
		wcout << L"\ndist2 = "; dist2.showdist();

		// перемножим два заданных интервала, меняя сомножители местами,
		// выведем результаты на экран
		Wdist = dist1 * dist2;
		wcout << L"\n\ndist1 * dist2 = " << Wdist << L" кв. футов";
		Wdist = dist2 * dist1;
		wcout << L"\ndist2 * dist1 = " << Wdist << L" кв. футов";

		// рассмотрим случай, когда один из интервалов задан вещественным числом футов,
		// поменяем сомножители местами, выведем результаты на экран
		// (при этом вещественное число футов конвертируется в объект класса Distance
		// с помощью конструктора с одним аргументом)
		Wdist = 7.5 * dist1;
		wcout << L"\n\n7.5 * dist1 = " << Wdist << L" кв. футов";
		Wdist = dist1 * 7.5;
		wcout << L"\ndist1 * 7.5 = " << Wdist << L" кв. футов\n";
	}
	else if (zadanie == 4) {
		const int ASIZE = 10; // количество элементов в массиве
		Array arr1(ASIZE);     // создаем массив arr1

		for (int j = 0; j < ASIZE; j++) // заполним массив arr1 квадратами целых чисел,
			arr1[j] = j * j;            // начав с нуля и двигаясь в положительную сторону

		// выведем на экран содержимое массива arr1
		wcout << L"arr1 = "; arr1.display(); wcout << endl;

		// тестируем копирующий конструктор
		Array arr2(arr1);
		// Array arr2 = arr1; // альтернативная форма вызова копирующего конструктора
		// выведем на экран содержимое массива arr2
		wcout << L"arr2 = "; arr2.display(); wcout << endl;

		// тестируем операцию присваивания массивов
		Array arr3(10), arr4(5), arr5(15);
		arr3 = arr1; // при равном количестве элементов
		arr4 = arr1; // количество элементов в присваиваемом массиве больше
		arr5 = arr1; // количество элементов в присваиваемом массиве меньше
		// выведем на экран содержимое массивов arr3, arr4, arr5
		wcout << L"arr3 = "; arr3.display(); wcout << endl;
		wcout << L"arr4 = "; arr4.display(); wcout << endl;
		wcout << L"arr5 = "; arr5.display(); wcout << endl;

		// тестируем присваивание самому себе
		arr1 = arr1;
		// выведем на экран содержимое массива arr1
		wcout << L"arr1 = "; arr1.display(); wcout << endl;

		// тестируем множественное присваивание
		Array arr6, arr7;
		arr7 = arr6 = arr1;
		// выведем на экран содержимое массивов arr6, arr7
		wcout << L"arr6 = "; arr6.display(); wcout << endl;
		wcout << L"arr7 = "; arr7.display(); wcout << endl;
	}
	else if (zadanie == 5) {
		publication* pubPtr[100]; // массив указателей на объекты класса publication
		int n = 0;                // количество действительно занятых элементов массива
		wchar_t choice;           // символ, отражающий выбор пользователя

		// пользователь в цикле вводит данные изданий
		do {
			wcout << L"Вводим бумажную или аудиокнигу? (б/а): "; wcin >> choice;
			if (choice == L'б')       // поместить новый объект-бумажную книгу
				pubPtr[n] = new book; //     в массив
			else                      // поместить новый объект-аудиокассету
				pubPtr[n] = new tape; //     в массив
			wcout << L"Ввод данных издания " << n + 1 << L":";
			pubPtr[n++]->getdata();   // получим данные издания у пользователя
			wcout << L"\nВвести следующее издание? (д/н): "; wcin >> choice; wcout << endl;
		} while (choice == L'д'); // цикл выполняется, пока ответ «да»

		// выведем на экран данные введенных выше изданий
		for (int j = 0; j < n; j++)
		{
			wcout << L"Данные издания " << j + 1 << L":";
			pubPtr[j]->putdata();
			// если издание слишком большого размера, выведем соответствующую пометку
			if (pubPtr[j]->isOversize()) wcout << L" (слишком большого размера!)\n";
		}
	}
	else if (zadanie == 6) {




	}
	else if (zadanie == 7) {
	bMoney mo1, mo2;

	// тестируем округление «вниз»
	mo1 = L"$1,234,567.23";           // задаем значение
	mo1.putmoney(); wcout << L" -> "; // и выводим его на экран
	mo2 = round(mo1);                 // округляем до долларов
	mo2.putmoney(); wcout << endl;    // выводим результат округления на экран

	// тестируем округление «вверх»
	mo1 = L"$1,234,567.50";           // задаем значение
	mo1.putmoney(); wcout << L" -> "; // и выводим его на экран
	mo2 = round(mo1);                 // округляем до долларов
	mo2.putmoney(); wcout << endl;    // выводим результат округления на экран
	}
	else if (zadanie == 8) {
	Stack s; // создадим стек

	// создадим объекты-токены обоих видов
	Number n1(6.02f), n2(3.333f), n3(75.25f), n4(2.0f), n5(3.14159f);
	Operator plus(L'+'), mult(L'*'), minus(L'-'), div(L'/');

	// вперемешку поместим в стек адреса объектов-токенов обоих видов
	s.push(&n1); s.push(&plus); s.push(&n2);
	s.push(&mult); s.push(&n3); s.push(&plus);
	s.push(&n4); s.push(&div); s.push(&n5);

	while (s.gettop() > 0) // пока стек не пуст
	{
		// будем извлекать объекты-токены обоих видов из стека и выводить их на экран

		// в зависимости от вида объекта-токена вызываем определенный метод,
		// возвращающий значение токена для вывода на экран
		if (s.isNumber())
			wcout << s.pop()->getNumber();
		else
			wcout << s.pop()->getOperator();

		// если объект-токен не последний в стеке, вывести пробел для разделения
		// токенов на экране
		if (s.gettop() > 0) wcout << L' ';
	}
	wcout << endl;
	}

	else if (zadanie == 9) {
		
	}
	else if (zadanie == 10) {
		
	}
	else if (zadanie == 11) {
	
	}
	else if (zadanie == 12) {
	
	}
}
