#include <io.h> 
#include <fcntl.h> 
#include <iostream>
#include <iomanip> 
#include <sstream> 
#include <Windows.h>
#define _CRT_SECURE_NO_WARNINGS 1
using namespace std;
////////////////////////////////  Для задания №2/5  ///////////////////////////////////////////////////
class publication {
private:
	string title;
	float price;
public:
	virtual void getdata() {
		cout << "Введите название издания  - ";
		getline(ws(cin), title);
		cout << "Введите цену экземпляра издания - ";
		cin >> price;
	}
	virtual void putdata() const {
		cout << endl << "Название издания - " << title;
		cout << endl << "Цена экземпляра издания - " << price << endl;
	}
	virtual bool isOversize() const = 0;// чистый виртуальный метод
};

class book : public publication {
private:
	int pages;
public:
	void getdata() {
		publication::getdata();
		cout << "Введите количество страниц в книге - ";
		cin >> pages;
	}
	void putdata() const {
		publication::putdata();
		cout << "Количество страниц в книге - " << pages << endl;
	}
	bool isOversize() const {// с помощью этого метода можно определить, не слишком ли большой размер у книги
		if (pages > 800)
			return true;
		else
			return false;
	}
};

class tape : public publication {
private:
	float playing_time;
public:
	void getdata() {
		publication::getdata();
		cout << "Введите время проигрывания аудиокниги в минутах - ";
		cin >> playing_time;
	}
	void putdata() const {
		publication::putdata();
		cout << "Время проигрывания аудиокниги в минутах - " << playing_time << endl;
	}
	bool isOversize() const {// с помощью этого метода можно определить, не слишком ли большая длительность у аудиокниги
		if (playing_time > 90)
			return true;
		else
			return false;
	}
};

////////////////////////////////  Для задания №3  ///////////////////////////////////////////////////
class Distance {
private:
	int feet;
	float inches;
public:
	Distance() : feet(0), inches(0.0)// конструктор без аргументов
	{ }
	// конструктор с одним аргументом (конвертирует float в Distance)
	Distance(float fltfeet) {
		feet = static_cast<int>(fltfeet);// футы 
		inches = 12 * (fltfeet - feet);// дюймы
	}
	// конструктор с двумя аргументами
	Distance(int ft, float in) : feet(ft), inches(in)
	{ }
	void showdist() const {// вывод полей на экран
		wcout << feet << "\'-" << inches << '\"';
	}
	// перемножение двух длин 
	// дружественная функция, не является членом класса
	friend float operator* (Distance, Distance);
};
// перемножение двух длин 
float operator* (Distance d1, Distance d2) {
	return (d1.feet + d1.inches / 12) * (d2.feet + d2.inches / 12);
}

////////////////////////////////  Для задания №4  ///////////////////////////////////////////////////
class Array {
private:
	int* ptr;// указатель на содержимое массива
	int size;// количество элементов в массиве
public:
	Array() : ptr(0), size(0)// конструктор без аргументов
	{ }
	Array(int s) {// конструктор с одним аргументом
		size = s;           // аргументом задается количество элементов в массиве
		ptr = new int[s];// выделим память под наш массив
	}
	Array(Array& arr) {// перегруженный копирующий конструктор
		size = arr.size; // копируем количество элементов присваиваемого массива
		ptr = new int[size];// выделим память под новый массив
		for (int i = 0; i < size; i++)// скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i);// в наш новый массив поэлементно
	}
	~Array() {// деструктор
		delete[] ptr;
	}
	int& operator[] (int j) {
		return *(ptr + j);
	}
	Array& operator= (Array& arr) {
		if (this == &arr) return *this;
		delete[] ptr;
		size = arr.size;// копируем количество элементов присваиваемого массива
		ptr = new int[size];// выделим память под новый массив
		for (int i = 0; i < size; i++)// скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i);// в наш новый массив поэлементно
		return *this;// возвращаем текущий объект
	}
	void display() { // вывод элементов массива на экран
		for (int i = 0; i < size; i++)
			cout << *(ptr + i) << ' ';
	}
};
////////////////////////////////  Для задания №6/7  ///////////////////////////////////////////////////
class bMoney {
private:
	long double sum;
public:
	bMoney() {
		sum = 0.0L;
	}
	explicit bMoney(long double n) : sum(n)
	{ }
	bMoney(const wchar_t s[]) {
		mstold(s);
	}

	long double mstold(const wchar_t[]);
	void ldtoms(wchar_t[]);
	void getmoney() {
		wchar_t tms[80];
		wcout << L"Введите денежную сумму (пример: '$1,234,567.99'):\n";
		wcin >> tms;
		mstold(tms);
	}
	void putmoney() {
		wchar_t tms[80];
		ldtoms(tms);
		wcout << tms;
	}
	bMoney operator+ (bMoney m) const {
		return bMoney(sum + m.sum);
	}
	bMoney operator- (bMoney m) const {
		return bMoney(sum - m.sum);
	}
	bMoney operator* (long double n) const {
		return bMoney(sum * n);
	}
	long double operator/ (bMoney m) const {
		return sum / m.sum;
	}
	bMoney operator/ (long double n) const {
		return bMoney(sum / n);
	}
	friend bMoney operator* (long double n, bMoney m) {
		return bMoney(n * m.sum);
	}
	friend long double operator/ (long double n, bMoney m) {
		return n / m.sum;
	}
	// дружественная для класса bMoney функция для округления денежной строки до долларов
	friend bMoney round(bMoney m) {
		long double i, f;// для целой и дробной части денежной строки
		f = modfl(m.sum, &i);// с помощью библиотечной функции modfl разделяем целую и дробную
							// части денежной строки и помещаем их в переменные i и f
		if (f < 0.50L)
			return bMoney(i);
		else
			return bMoney(i + 1.0L);
	}
};
//////
// 
// 
long double bMoney::mstold(const wchar_t str[]) {
	wchar_t temp[80];
	int j = 0;
	for (int i = 0; i < wcslen(str); i++) {
		wchar_t ch = str[i];
		if ((ch >= '0') && (ch <= '9'))
			temp[j++] = ch;
		else if (ch == '.')
			temp[j++] = ch;
	}
	temp[j] = '\0';

	wchar_t* stop;
	sum = wcstold(temp, &stop);

	return sum;
}

void bMoney::ldtoms(wchar_t str[]) {
	wchar_t ustring[80];
	wstringstream woss;

	woss << setiosflags(ios::fixed) << setprecision(2) << sum;
	woss >> ustring;

	int i = 0, n = 0, j;
	int len = wcslen(ustring);
	wchar_t delim3 = ',';

	str[i++] = '$';

	if (len > 6) {
		if ((len - 3) % 3 == 2) {
			str[i++] = ustring[n++];
			str[i++] = ustring[n++];
			str[i++] = delim3;
		}
		else if ((len - 3) % 3 == 1) {
			str[i++] = ustring[n++];
			str[i++] = delim3;
		}
	}

	for (j = n; j < len - 3; j++) {
		str[i++] = ustring[j];
		if (((j - n + 1) % 3 == 0) && (j != len - 3 - 1))
			str[i++] = delim3;
	}
	str[i++] = ustring[j++];
	str[i++] = ustring[j++];
	str[i++] = ustring[j];
	str[i] = '\0';
}
////////////////////////////////  Для задания №8/11  ///////////////////////////////////////////////////
const int LEN = 80;// максимальная длина арифметического выражения (в символах)
const int MAX = 40;// размер стека

class Token {// абстрактный базовый клас
			// у нас будут два вида токенов — вещественное число и арифметическая
			// операция
public:
	// чистые виртуальные функции
	virtual float getNumber() const = 0;
	virtual char getOperator() const = 0;
};

class Operator : public Token {// класс, представляющий токен «арифметическая операция»
private:
	char oper;// знак арифметической операции
public:
	Operator(char op) : oper(op)// конструктор с одним аргументом
	{ }
	char getOperator() const {// метод выдает знак операции
		return oper;
	}
	float getNumber() const {// фиктивная функция
		return 0.0;
	}
};

class Number : public Token {// класс, представляющий токен «вещественное число»
private:
	float fnum;// вещественное число
public:
	Number(float n) : fnum(n)// конструктор с одним аргументом
	{ }
	float getNumber() const {// метод выдает значение вещественного числа
		return fnum;
	}
	char getOperator() const {// фиктивная функция
		return '0';
	}
};

class Stack {// класс, реализующий стек
private:
	Token* atoken[MAX];// стек в виде массива указателей на токены
	int top;// индекс, указывающий на вершину стека
public:
	Stack() {// конструктор без аргументов
		top = 0;
	}
	void push(Token* var) {// поместить токен в стек
		atoken[++top] = var;
	}
	Token* pop() {// забрать токен из стека
		return atoken[top--];
	}
	int gettop() const {// получить индекс, указывающий на вершину стека
		return top;
	}
	bool isNumber() const {// метод определяет, является ли токен на вершине стека  вещественным числом
		Number* pNum;
		if (pNum = dynamic_cast<Number*>(atoken[top]))
			return true;
		else
			return false;
	}
};

class express {// класс, представляющий арифметическое выражение
private:
	Stack s;// стек для анализа арифметического выражения
	char* pStr;// указатель на заданную строку с арифметическим выражением
	int len;// длина заданной строки
public:
	express(char* ptr) {// конструктор с одним аргументом
		pStr = ptr; // запоминаем указатель на заданную строку
		len = strlen(pStr);// запоминаем длину заданной строки
	}
	void parse();// разбор заданной строки с арифметическим выражением
	float solve();// вычисление арифметического выражения, оставшегося в стеке
};

void express::parse() {
	char ch;// символ из заданной строки с арифметическим выражением
	Token* lastval;// последнее помещенное в стек число(операнд)
	Token* lastop;// последний помещенный в стек знак операции

	float ans;// для вещественных чисел
	Number* ptrN;// для указателей на токены-числа
	Operator* ptrO;// для указателей на токены-операции
	// указатель на текущую анализируемую позицию в строке с арифметическим выражение
	char* pCurrent = pStr;

	while (pCurrent[0]) {// пока не достигнут конец анализируемой строки
		// получим символ из текущей анализируемой позиции в строке с арифметическим выражением
		ch = pCurrent[0];
		if (ch >= '0' && ch <= '9') {// если это цифра
			ans = strtof(pCurrent, &pCurrent); // получим из строки вещественное число
			ptrN = new Number(ans);// выделим память под токен-число
			s.push(ptrN);// поместим токен в стек
		}// если это знак арифметической операции
		else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
			if (s.gettop() == 1) {// если это первый в выражении знак операции
				ptrO = new Operator(ch);// выделим память под токен-операцию
				s.push(ptrO); // поместим токен в стек
			}
			else {// это не первый в выражении знак операции
				lastval = s.pop(); // получаем предыдущее в анализе число-операнд
				lastop = s.pop();// получаем предыдущий в анализе знак операции
				// если наш знак операции * или /, а предыдущий был + или -, то
				if ((ch == '*' || ch == '/') && (lastop->getOperator() == '+' || lastop->getOperator() == '-')) {
					s.push(lastop);// отменяем последние два взятия из стека
					s.push(lastval);
				}
				else {// во всех других случаях
					// выполним предыдущую операцию и поместим результат в стек
					switch (lastop->getOperator()) {
					case '+':
						ans = s.pop()->getNumber() + lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					case '-':
						ans = s.pop()->getNumber() - lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					case '*':
						ans = s.pop()->getNumber() * lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					case '/':
						ans = s.pop()->getNumber() / lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					default: cout << "\nНеизвестный знак операции\n"; exit(1);
					}
				}
				Operator* ptrO = new Operator(ch);// выделим память под токен-операцию
				s.push(ptrO);                   // поместим токен в стек
			}
			pCurrent++;// указатель pCurrent передвигаем на следующий токен
		}
		else {// если символ не является ни вещественным числом, ни знаком операции
			cout << "\nНеразрешенный символ в арифметическом выражении\n"; exit(1);
		}
	}
}
// вычисление арифметического выражения, оставшегося в стеке
float express::solve() {
	Token* lastval;// последнее помещенное в стек число(операнд)

	float ans;// для вещественных чисел
	Number* ptrN;// для указателей на токены-числа

	while (s.gettop() > 1) {// пока в стеке не останется результат вычисления
							// нашего арифметического выражения,
		lastval = s.pop();// получим последнее в анализе число-операнд
		switch (s.pop()->getOperator()) {// получим последний в анализе знак операции
											// выполним операцию и поместим результат в стек
		case '+':
			ans = s.pop()->getNumber() + lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		case '-':
			ans = s.pop()->getNumber() - lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		case '*':
			ans = s.pop()->getNumber() * lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		case '/':
			ans = s.pop()->getNumber() / lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		default: cout << "\nНеизвестный знак операции\n"; exit(1);
		}
	}


	return s.pop()->getNumber();// в стеке остался результат вычисления выражения,
								 // забираем его и возвращаем; стек остается пустым
}

////////////////////////////////  Для задания №9  ///////////////////////////////////////////////////
const int CPF = 5;
const int maxHorses = 7;

class track;

class horse {
private:
	const track* ptrTrack;
	int horse_number;
	float distance_run;
public:
	horse() {}
	horse(const int n, const track* ptrT) : horse_number(n), ptrTrack(ptrT) {
		distance_run = 1 + rand() % 100;
	}
	float dist() {
		return distance_run;
	}
};
class track {
protected:
	horse* hArray[maxHorses];
	int total_horses;
	int horse_count;
public:
	track(int nH) : total_horses(nH), horse_count(0) {
		total_horses = (total_horses > maxHorses) ? maxHorses : total_horses;
		for (int j = 0; j < total_horses; j++) {
			hArray[j] = new horse(horse_count++, this);
		}
	}
	~track() {
		for (int j = 0; j < total_horses; j++) {
			delete hArray[j];
		}
	}
	int tot_horses() {
		return total_horses;
	}
};

class comHorse : public track, public horse {
	float max_distance, pred_max_distance;
public:
	comHorse(int nH) : track(nH) {
		max_distance = 0.0;
		pred_max_distance = 0.0;
		for (int i = 0; i < nH; i++) {
			if (hArray[i]->dist() > max_distance) {
				pred_max_distance = max_distance;
				max_distance = hArray[i]->dist();
			}
		}
	}
	void test_horse(int index) {
		if (hArray[index]->dist() < max_distance) {
			cout << "Лошадь не первая! Ускорится!\n";
		}
		else
		{
			if ((hArray[index]->dist() - 7.0) >= pred_max_distance) {
				cout << "Лошадь первая! Ускоряться не следует\n";
			}
			else {
				cout << "Лошадь первая! Но соперник на подходе, ускоряемся!\n";
			}
		}
	}
	void output_distance() {
		for (int i = 0; i < total_horses; i++) {
			cout << "Лошадь " << i + 1 << ": " << hArray[i]->dist() << endl;
		}
	}
};
////////////////////////////////  Для задания №10  ///////////////////////////////////////////////////
struct link {// элемент списка
	int data;// данные
	link* next;// указатель на следующий элемент списка
};

class linklist {// класс, представляющий связный список
private:
	link* first;// указатель на первый элемент списка
public:
	linklist() {// конструктор без аргументов
		first = NULL;
	}
	linklist(linklist&); // перегруженный копирующий конструктор (прототип)
	~linklist();// деструктор (прототип)
	void additem(int d);// добавление элемента списка(прототип)
	void display(); // вывод на экран данных из всех элементов списка(прототип)
	linklist& operator= (linklist&);// перегруженный оператор присваивания (прототип)
};

linklist::linklist(linklist& li) {// перегруженный копирующий конструктор
	first = NULL;// новый связный список пока пуст
	// от копирующего конструктора требуется выделить память под новый связный список
	// и перекопировать в этот новый связный список элементы списка-аргумента li

	link* current = li.first;// начинаем с первого элемента списка-аргумента
	while (current) { // пока не достигнут конец списка-аргумента
		additem(current->data);// выделим память под новый элемент нового связного списка
								 // и запишем в него данные из текущего элемента списка-аргумента
		current = current->next;// перейдем к следующему элементу списка-аргумента
	}
}

void linklist::additem(int d) {// добавление элемента списка
	link* newlink = new link;// выделяем память под новый элемент списка
	newlink->data = d;// сохраняем в него данные
	newlink->next = first; // указатель на следующий элемент списка
							  // теперь будет указывать на элемент, который
							  // до этого был первым
	first = newlink;// первым теперь стал только что созданный элемент,
							  // то есть добавление элементов происходит
							  // в начало связанного списка
}

void linklist::display() {// вывод на экран данных из всех элементов списка
	link* current = first;// начинаем с первого элемента
	while (current) {// пока указатель на текущий элемент не равен NULL
		cout << current->data << ' ';// выводим данные
		current = current->next;// переходим к следующему элементу
	}
	cout << endl;
}
// деструктор (реализация)
linklist::~linklist() {
	link* current = first;// начинаем с первого элемента
	while (current) {// пока не конец (NULL) списка
		first = current->next;// первым становится предыдущий элемент
		delete current;// освобождаем память, занятую текущим элементом
		cout << "Элемент списка удалён." << endl;// сообщение 
		current = first;// теперь текущий элемент тот, который ранее
							   // был предыдущим
	}
}

linklist& linklist::operator= (linklist& li) {// перегруженный оператор присваивания
	if (this == &li) return *this;// проверка на присваивание самому себе
	// от оператора присваивания требуется удалить старый связный список, затем
	// выделить память под новый связный список и перекопировать в этот новый связный список
	// элементы списка-аргумента li
	// удаление старого связного списка
	link* current = first;  // начинаем с первого элемента
	while (current) {// пока не конец (NULL) списка
		first = current->next;// первым становится предыдущий элемент
		delete current;// освобождаем память, занятую текущим элементом
		current = first;// теперь текущий элемент тот, который ранее
							   // был предыдущим
	}
	// выделяем память под новый связный список и перекопируем в этот новый связный список
	// элементы списка-аргумента
	current = li.first;// начинаем с первого элемента списка-аргумента
	while (current) {// пока не достигнут конец списка-аргумента
		additem(current->data);// выделим память под новый элемент нового связного списка
								 // и запишем в него данные из текущего элемента списка-аргумента
		current = current->next;// перейдем к следующему элементу списка-аргумента
	}
	return *this;// вернуть текущий объект
}

/// ////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

int main() {
	setlocale(0, "");
	int zadanie;
	cout << "Введите номер задания - ";
	cin >> zadanie;
	if (zadanie == 1) {

	}
	else if (zadanie == 2) {;
		publication* pubPtr[100];// массив указателей на объекты класса publication
		int n = 0;// количество действительно занятых элементов массива
		char choice;// для y/n и б/а

		do {
			cout << "Вводим бумажную или аудиокнигу? (b/a) - ";
			cin >> choice;
			if (choice == 'b')
				pubPtr[n] = new book;
			else
				pubPtr[n] = new tape;
			cout << "Ввод данных издания " << n + 1 << " - " << endl;
			pubPtr[n++]->getdata();
			cout << "\nВвести следующее издание? (d/n) - ";
			cin >> choice;
			cout << endl;
		} while (choice == 'y');

		for (int j = 0; j < n; j++) {
			cout << "Данные издания " << j + 1 << ":";
			pubPtr[j]->putdata();
			// если издание слишком большого размера, выведем соответствующую пометку
			if (pubPtr[j]->isOversize()) cout << "Превышение размера!\n";
		}
	}
	else if (zadanie == 3) {
		Distance dist1 = 1.0;
		Distance dist2 = 2.0;
		float Wdist;// для хранения результата перемножения двух объектов класса Distance
		// заданы два интервала в английских мерах длины, покажем их на экране
		cout << "dist1 = ";
		dist1.showdist();
		cout << "\ndist2 = ";
		dist2.showdist();
		// перемножим два заданных интервала, меняя сомножители местами,
		// выведем результаты на экран
		Wdist = dist1 * dist2;
		cout << "\n\ndist1 * dist2 = " << Wdist << " кв.футов";
		Wdist = dist2 * dist1;
		cout << "\n\ndist2 * dist1 = " << Wdist << " кв.футов";

		// рассмотрим случай, когда один из интервалов задан вещественным числом футов,
		// поменяем сомножители местами, выведем результаты на экран
		Wdist = 2.0 * dist1;
		cout << "\n\n2.0 * dist1 = " << Wdist << " кв.футов";
		Wdist = dist2 * 2.0;
		cout << "\n2.0*dist2 = " << Wdist << " кв.футов\n";

	}
	else if (zadanie == 4) {
		const int ASIZE = 10;// количество элементов в массиве
		Array arr1(ASIZE);

		for (int j = 0; j < ASIZE; j++)// заполним массив arr1 квадратами целых чисел
			arr1[j] = j * j;

		cout << "arr1 = ";
		arr1.display();
		cout << endl;
		// тестируем копирующий конструктор
		Array arr2(arr1);
		cout << "arr2 = ";

		arr2.display();
		cout << endl;
		// тестируем операцию присваивания массивов
		Array arr3(5), arr4(10), arr5(15);
		arr3 = arr1;
		arr4 = arr1;
		arr5 = arr1;
		cout << "arr3 = "; arr3.display(); cout << endl;
		cout << "arr4 = "; arr4.display(); cout << endl;
		cout << "arr5 = "; arr5.display(); cout << endl;
		// тестируем присваивание самому себе
		arr1 = arr1;
		cout << "arr1 = ";
		arr1.display();
		cout << endl;
		// тестируем множественное присваивание
		Array arr6, arr7;
		arr7 = arr6 = arr1;
		cout << "arr6 = "; arr6.display(); cout << endl;
		cout << "arr7 = "; arr7.display(); cout << endl;

	}
	else if (zadanie == 5) {
		publication* pubPtr[100];// массив указателей на объекты класса publication
		int n = 0;// количество действительно занятых элементов массива
		char choice;// для y/n и б/а
		do {
			cout << "Вводим бумажную или аудиокнигу? (б/а): ";
			cin >> choice;
			if (choice == 'б')
				pubPtr[n] = new book;
			else
				pubPtr[n] = new tape;
			cout << "Ввод данных издания " << n + 1 << ":";
			pubPtr[n++]->getdata();
			wcout << "\nВвести следующее издание? (y/n): ";
			cin >> choice;
			cout << endl;
		} while (choice == 'y');

		for (int j = 0; j < n; j++) {
			cout << "Данные издания " << j + 1 << ":";
			pubPtr[j]->putdata();
			// если издание слишком большого размера, выведем соответствующую пометку
			if (pubPtr[j]->isOversize()) cout << " Превышение размера!\n";
		}

	}
	else if (zadanie == 6) {
	wchar_t ans;
	bMoney m1, m2, mres;// для двух денежных сумм и результата операций
	long double n, res;// для вещественного числа и результата операций

	do {
		wcout << "1. "; m1.getmoney();
		wcout << "2. "; m2.getmoney();
		wcout << L"3. Введите вещественное число: "; wcin >> n; wcout << endl;
		// выполняем перегруженные операции и выводим результаты на экран
		mres = m1 + m2; wcout << "1. m1 + m2 = "; mres.putmoney(); wcout << endl;
		mres = m1 - m2; wcout << "2. m1 - m2 = "; mres.putmoney(); wcout << endl;
		mres = m1 * n;  wcout << "3. m1 * n  = "; mres.putmoney(); wcout << endl;
		res = m1 / m2; wcout << "4. m1 / m2 = " << res << endl;
		mres = m1 / n;  wcout << "5. m1 / n  = "; mres.putmoney(); wcout << endl;

		mres = n * m1;  wcout << "6. n * m1  = "; mres.putmoney(); wcout << endl;

		res = n / m1;   wcout << "7. n / m1 = " << res << endl << endl;

		wcout << L"Попробовать с другими исходными данными (y/n)? "; wcin >> ans; wcout << endl;
	} while (ans != 'n');
	}
	else if (zadanie == 7) {
	_setmode(_fileno(stdout), _O_U16TEXT);

	bMoney mo1, mo2;
	// тестируем округление «вниз»
	mo1 = L"$1,234,567.23";
	mo1.putmoney();
	wcout << " -> ";
	mo2 = round(mo1);
	mo2.putmoney();
	wcout << endl;
	// тестируем округление «вверх»
	mo1 = L"$1,234,567.50";
	mo1.putmoney(); wcout << " -> ";
	mo2 = round(mo1);
	mo2.putmoney(); wcout << endl;

	}
	else if (zadanie == 8) {
		Stack s;// создадим стек
			// создадим объекты-токены обоих видов
		Number n1(1.0f), n2(3.333f), n3(2.75f), n4(5.0f), n5(3.14159f);
		Operator plus('+'), mult('*'), minus('-'), div('/');
		//поместим в стек адреса объектов-токенов обоих видов
		s.push(&n1); s.push(&plus); s.push(&n2);
		s.push(&mult); s.push(&n3); s.push(&plus);
		s.push(&n4); s.push(&div); s.push(&n5);

		while (s.gettop() > 0) {// пока стек не пуст
			// будем извлекать объекты-токены обоих видов из стека и выводить их на экран
			// в зависимости от вида объекта-токена вызываем определенный метод,
			// возвращающий значение токена для вывода на экран
			if (s.isNumber())
				cout << s.pop()->getNumber();
			else
				cout << s.pop()->getOperator();
			// если объект-токен не последний в стеке, вывести пробел для разделения
			// токенов на экране
			if (s.gettop() > 0) cout << ' ';
		}
	}
	else if (zadanie == 9) {
		srand(time(0));
		int total;
		cout << "Введите количество лошадей (от 1 до 7): ";
		cin >> total;
		comHorse cH(total);
		cH.output_distance();
		cout << endl;
		for (int i = 0; i < total; i++) {
			cH.test_horse(i);
		}
	}
	else if (zadanie == 10) {
		linklist* list1 = new linklist;// создаем связный список
	// добавляем 3 элемента в список
		list1->additem(1);
		list1->additem(2);
		list1->additem(3);
			
		// выведем список на экран
		cout << "list1 = ";
		list1->display();
			
		linklist list2(*list1);// тестируем перегруженный копирующий конструктор

		linklist list3;
		list3 = *list1;// тестируем перегруженный оператор присваивания
		// удалим первоначальный список
		delete list1;
		// выводим тестовые списки на экран
		cout << "list2 = ";
		list2.display();
		cout << "list3 = ";
		list3.display();
	}
	else if (zadanie == 11) {
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	char ans;// y/n?
	char string[LEN];// строка с арифметическим выражением для разбора

	cout << "Введите арифметическое выражение, например: 2.5+3.0*4/3.148-2.84" "\nЧисла могут быть вещественными и состоять из нескольких цифр." "\nНе используйте пробелы и скобки.\n";

	do {
		cout << "\nВведите выражение: ";// получаем строку от пользователя
		ws(cin);// предварительно убрав из потока cin ведущие пробельные символы
		cin.get(string, LEN);
		express* eptr = new express(string);// создаем объект-выражение для разбора
		eptr->parse();// выполняем разбор  выражения
		cout << "Результат вычисления выражения: " << eptr->solve();// получаем результат вычисления
		delete eptr; // удаляем объект-выражение
		cout << "\nЕще одно выражение (y/n)? ";
		cin >> ans;
	} while (ans == 'y');

	}
	else if (zadanie == 12) {

	}
}
