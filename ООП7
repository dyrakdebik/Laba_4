#include <io.h> // для функции _setmode
#include <iostream>
#include <iomanip> // для манипуляторов setiosflags, setprecision
#include <sstream>
#define _CRT_SECURE_NO_WARNINGS 1
using namespace std;
const double PI = 3.141592653589793; // 15 знаков после точки
// Множитель для преобразования градусов в радианы
const double factor = PI / 180.0;
const double RATE = 50.0; // курс обмена валют: 1 фунт = 50 долларов
/// ///////////////////   №1   ////////////////////////////////////////////
class time
{
private: 
	float hrs, mins, secs; 
public:
	time() : 
		hrs(0), mins(0), secs(0) {} 
	time(int h, int m, int s) : 
		hrs(h), mins(m), secs(s) { }
	void display() { 
	cout << hrs << ":" << mins << ":" << secs; }
	time operator + (time t2) //add two times 
	{
		int s = secs + t2.secs; //add seconds 
		int m = mins + t2.mins; //add minutes 
		int h = hrs + t2.hrs; //add hours 
		if( s > 59 ) //if secs overflow, 
		{ s -= 60; m++; } // carry a minute 
		if( m > 59 ) //if mins overflow, 
		{ m -= 60; h++; } // carry an hour 
		return time(h, m, s); //return temp value 
	}
	//ПРЕФИКСНАЯ
	time& operator ++() {
		this->hrs++;
		this->mins++;
		this->secs++;
		return *this;
	}
	time& operator --() {
		this->hrs--;
		this->mins--;
		this->secs--;
		return *this;
	}
	//ПОСТФИКСНАЯ
	time& operator ++(int magic) {
		time temp(*this);
		this->hrs++;
		this->mins++;
		this->secs++;
		return temp;
	}
	time& operator --(int magic) {
		time temp(*this);
		this->hrs--;
		this->mins--;
		this->secs--;
		return temp;
	}
	time operator - (time t2) //add two times 
	{
		int s = secs - t2.secs; //add seconds 
		int m = mins - t2.mins; //add minutes 
		int h = hrs - t2.hrs; //add hours 
		if (s > 59) //if secs overflow, 
		{
			s -= 60; m++;
		} // carry a minute 
		else if (s < 0) {
			s = 60 - s;
			m--;
		}
		if (m > 59) //if mins overflow, 
		{
			m -= 60; h++;
		} // carry an hour 
		else if (m < 0) {
			m = 60 - m;
			h--;
		}
		if (h < 0) {
			cout << "Время отрицательное - ошибка";
		}
		return time(h, m, s); //return temp value 
	}
	time(float h, float m, float s) :
		hrs(h), mins(m), secs(s) { }
	time operator * (time t2) //add two times 
	{
		float s = secs * t2.secs; //add seconds 
		float m = mins * t2.mins; //add minutes 
		float h = hrs * t2.hrs; //add hours 
		int b;
		if (s > 59) //if secs overflow, 
		{
			b = s / 60;
			s = s-b*60;
			m = m + b;
		} // carry a minute 
		if (m > 59) //if mins overflow, 
		{
			b = m / 60;
			m = m - b * 60;
			h = h+ b;
		} // carry an hour 
		return time(h, m, s); //return temp value 
	}
 };
class fraction // класс, представляющий обыкновенную дробь
{
private:
	int chisl;
	int znam; 
public:
	fraction(){ }
	fraction(int n, int d) : chisl(n), znam(d) { }
	void get() {
		char slash;
		cout << "Введите дробь - ";
		cin >> chisl >> slash >> znam;
	}
	void display() {
		cout << "Результат операции: " << chisl << '/' << znam << endl;
	}
	fraction operator+ (fraction f) const
	{
		// создаем временный безымянный объект нашего класса с результатом сложения
		// заданных обыкновенных дробей, применяем к нему сокращение до несократимого вида
		// и возвращаем результат
		return fraction(chisl * f.znam + f.chisl * znam, znam * f.znam).lowterms();
	}
	// перегрузка операции вычитания (-) для нахождения разности двух обыкновенных дробей
	fraction operator- (fraction f) const
	{
		return fraction(chisl * f.znam - f.chisl * znam, znam * f.znam).lowterms();
	}
	// перегрузка операции умножения (*) для нахождения произведения двух обыкновенных дробей
	fraction operator* (fraction f) const
	{
		return fraction(chisl * f.chisl, znam * f.znam).lowterms();
	}
	// перегрузка операции деления (/) для нахождения частного от деления
	// одной обыкновенной дроби на другую
	fraction operator/ (fraction f) const
	{
		return fraction(chisl * f.znam, znam * f.chisl).lowterms();
	}
	// перегрузка операции сравнения «равно» (==) для обыкновенных дробей
	bool operator == (fraction f) const
	{
		if ((chisl == f.chisl) && (znam == f.znam))
			return true;
		else
			return false;
	}
	// перегрузка операции сравнения «не равно» (!=) для обыкновенных дробей
	bool operator != (fraction f) const
	{
		if ((chisl == f.chisl) && (znam == f.znam))
			return false;
		else
			return true;
	}
	// метод (прототип) для сокращения дроби до несократимого вида
	// (возвращение преобразованной дроби добавлено, чтобы можно было использовать
	// этот метод в перегруженных операциях сложения, вычитания, умножения и деления)
	fraction lowterms() {
		long chisl0, znam0, temp0, odel;
		chisl0 = labs(chisl);
		znam0 = labs(znam);
		if (znam0 == 0) {
			cout << "Недопустимый знаменатель!"; ;
		}
		else if (chisl0 == 0) {
			chisl = 0; znam = 1; 
			return fraction(chisl, znam);
		}

		// нахождение наибольшего общего делителя (Алгоритм Евклида)
		while (chisl0 != 0)
		{
			// добьемся, чтобы числитель был больше
			if (chisl0 < znam0)                               // если числитель меньше знаменателя,
			{
				temp0 = chisl0; chisl0 = znam0; 
				znam0 = temp0;
			} // меняем их местами

			chisl0 = chisl0 - znam0;
		}
		odel = znam0;

		chisl = chisl / odel; // делим числитель и знаменатель на
		znam = znam / odel; // полученный наибольший общий делитель

		// (возвращение преобразованной дроби добавлено, чтобы можно было использовать
		// этот метод в перегруженных операциях сложения, вычитания, умножения и деления)
		return fraction(chisl, znam);
	}
};
/// //////////////////////////////////////////////////8 ЗАдание//////////////////////////////////////////////////////////////////////
class bMoney
{
private:
	long double sum;
public:
	bMoney() {
		sum = 0.0;
	}
		//	конструктор с одним параметром(преобразование из long double в bMoney)
		// (с помощью служебного слова explicit делаем возможным использование
		// конструктора только в виде конструктора, а не для неявных преобразований)
	explicit bMoney(long double n) : sum(n){}
	bMoney(const char s[]) {
		mstold(s);
	}
	long double mstold(const char str[])
	{
		char temp[100];
		int j = 0;
		for (int i = 0; i < strlen(str); i++)
		{
			char simvol = str[i];

			if ((simvol >= '0') && (simvol <= '9'))
				temp[j++] = simvol;
			else if (simvol == '.')
				temp[j++] = simvol;
		}
		temp[j] = '\0';

		char* stop;
		sum = strtold(temp, &stop);
		return sum;
	}
	void ldtoms(char str[])
	{
		char ustring[80];
		stringstream woss;  
		woss << setiosflags(ios::fixed) << setprecision(2) << sum;
		woss >> ustring;

		int i = 0, n = 0, j;
		int len = strlen(ustring);
		char delim3 = ',';

		str[i++] = '$';

		if ((len - 3) % 3 == 2) {
			str[i++] = ustring[n++];
			str[i++] = ustring[n++];
			str[i++] = delim3;
		}
		else if ((len - 3) % 3 == 1) {
			str[i++] = ustring[n++];
			str[i++] = delim3;
		}

		for (j = n; j < len - 3; j++) {
			str[i++] = ustring[j];
			if (((j - n + 1) % 3 == 0) && (j != len - 3 - 1))
				str[i++] = delim3;
		}

		str[i++] = ustring[j++];
		str[i++] = ustring[j++];
		str[i++] = ustring[j];
		str[i] = '\0';
	}
	void getmoney() {
		char USAdolg[100];
		cin >> USAdolg;
		mstold(USAdolg);
	}
	void putmoney() {
		char USAdolg[80];
		ldtoms(USAdolg);
		cout << USAdolg;
	}
	bMoney operator+ (bMoney m) const {
		return bMoney(sum + m.sum);
	}
	// операция нахождения разности двух объектов класса
	bMoney operator- (bMoney m) const {
		return bMoney(sum - m.sum);
	}
	// операция нахождения произведения объекта класса и числа типа long double
	bMoney operator* (long double n) const {
		return bMoney(sum * n);
	}
	// операция нахождения частного от деления объекта класса на другой объект класса
	long double operator/ (bMoney m) const {
		return sum / m.sum;
	}
	// операция нахождения частного от деления объекта класса на число типа long double
	bMoney operator/ (long double n) const {
		return bMoney(sum / n);
	}
	bMoney(sterling s)
	{
		// преобразование double(s) определено в классе sterling, в результате получаем
		// сумму в десятичных фунтах, умножая которую на константу RATE переводим ее в доллары
		sum = double(s) * RATE;
	}
	operator sterling()
	{
		// выражение (sum / RATE) — перевод суммы в долларах в десятичные фунты,
		// далее создаем безымянный объект класса sterling с помощью конструктора
		// с одним аргументом, который преобразует десятичные фунты в фунты,
		// шиллинги и пенсы старой английской системы
		return sterling(sum / RATE);
	}
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const int LIMIT = 100;
class safearray
{
private:
	int arr[LIMIT];
	int gran_snizy; 
	int gran_sverhy; 
public:
	safearray(int niz, int vverh) : gran_snizy(niz), gran_sverhy(vverh)
	{
		if (gran_snizy > gran_sverhy)
		{
			int a = gran_snizy;
			gran_snizy = gran_sverhy;
			gran_sverhy = a;
		}
		if (gran_sverhy - gran_snizy >= LIMIT)
		{
			cout << "Слишком много элементов";
		}
	}
	int& operator[] (int n)
	{
		if (n < gran_snizy || n > gran_sverhy)
		{
			cout << "Неверный индекс";
		}
		return arr[n - gran_snizy];
	}
};

	/// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Polar
{
private:
	double radius, gradys;
public:
	void get() {
		cout << "Введите радиус: "; 
		cin >> radius;
		cout << "Введите угол - "; 
		cin >> gradys;
	}
	void operator+(const Polar& temp0)
	{
		double x1 = 0.0, x2 = 0.0, y1 = 0.0, y2 = 0.0, x3 = 0.0, y3 = 0.0, radius3 = 0.0, gradys3 = 0.0;
		x1 = radius * cos(gradys * factor);
		y1 = radius * sin(gradys * factor);
		cout << "Координаты первой точки - " << x1 << "; " << y1 << endl;
		x2 = temp0.radius * cos(temp0.gradys * factor);
		y2 = temp0.radius * sin(temp0.gradys * factor);
		cout << "Координаты второй точки - " << x2 << "; " << y2 << endl;
		x3 = x1 + x2;
		y3 = y1 + y2;
		cout << "Координаты новой точки - " << x3 << "; " << y3 << endl;
		radius3 = sqrt(pow(x3, 2) + pow(y3, 2));
		gradys3 = acos(x3 / radius3) * 180 / PI;
		cout << "Координаты новой точки в полярной системе - " << radius3 << "; " << gradys3 << endl;
	}
};
/// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class sterling // класс, представляющий денежную сумму в старой английской системе
{
private:
	long pounds;   // фунты (1 фунт = 20 шиллингов = 240 пенсов)
	int shillings; // шиллинги (1 шиллинг = 12 пенсов)
	int pences;    // пенсы
public:
	// конструктор без аргументов
	sterling() : pounds(0), shillings(0), pences(0)
	{ }
	// конструктор с одним аргументом
	// (для преобразования десятичных фунтов в денежную сумму в старой системе)
	sterling(double df)
	{
		// в этих формулах используется то обстоятельство, что при присвоении
		// целочисленной переменной вещественного значения дробная часть отбрасывается
		pounds = df;
		shillings = (df - pounds) * 20;
		// в случае пенсов необходимо округление до ближайшего целого (функция round),
		// а не отбрасывание дробной части
		pences = round(((df - pounds) * 20 - shillings) * 12);
	}
	// конструктор с тремя аргументами
	sterling(long ps, int s, int p) : pounds(ps), shillings(s), pences(p)
	{ }
	// метод для получения от пользователя денежной суммы в старой системе
	// в формате "£9.19.11"
	void getSterling()
	{
		// чтобы символ фунта отобразился в консоли, шрифт в консоли должен быть юникодным,
		// например, шрифт "ucida Console" или "Consolas"

		char separator; // для точки, разделяющей фунты, шиллинги и пенсы
		cout << "Введите сумму (фунты, шиллинги и пенсы через точку): £";
		cin >> pounds >> separator >> shillings >> separator >> pences;
	}
	// метод для вывода денежной суммы в старой системе на экран
	// в формате "£9.19.11"
	void putSterling() const
	{
		// чтобы символ фунта отобразился в консоли, шрифт в консоли должен быть юникодным,
		// например, шрифт "ucida Console" или "Consolas"

		cout << "£" << pounds << "." << shillings << "." << pences;
	}
	// операция преобразования объекта класса (денежной суммы в старой системе)
	// в число типа double (денежную сумму в десятичных фунтах)
	operator double() const
	{
		// так как в этом арифметическом выражении используются вещественные числа
		// (по умолчанию это тип double), то результат выражения тоже будет приведен
		// к вещественному типу (double в данном случае)
		return (pounds + shillings / 20.0 + pences / 240.0);
	}
	// перегрузка операции сложения (+) для сложения двух объектов класса
	// (результат тоже будет объектом класса)
	sterling operator+ (sterling s) const
	{
		// 1) sterling(pounds, shillings, pences) — создание безымянного объекта класса
		// с помощью конструктора с тремя аргументами. Обозначим это выражение как s1

		// 2) double(s1) и double(s) — создание безымянных переменных типа double с
		// помощью операции преобразования объекта класса в число типа double,
		// определенной выше (сумма из старой системы преобразуется в десятичные фунты)

		// 3) sterling(double(s1) + double(s)) — создание безымянного объекта класса
		// с помощью конструктора с одним аргументом (из десятичных фунтов в сумму
		// в старой системе)

		return sterling(double(sterling(pounds, shillings, pences)) + double(s));
	}
	// перегрузка операции вычитания (-) для нахождения разности двух объектов класса
	// (результат тоже будет объектом класса)
	sterling operator- (sterling s) const
	{
		return sterling(double(sterling(pounds, shillings, pences)) - double(s));
	}
	// перегрузка операции умножения (*) для нахождения произведения объекта класса
	// и числа типа double (результатом будет объект класса)
	sterling operator* (double n) const
	{
		return sterling(double(sterling(pounds, shillings, pences)) * n);
	}
	// перегрузка операции деления (/) для нахождения частного от деления объекта
	// класса на другой объект класса (результатом будет число типа double)
	double operator/ (sterling s) const
	{
		return (double(sterling(pounds, shillings, pences)) / double(s));
	}
	// перегрузка операции деления (/) для нахождения частного от деления объекта
	// класса на число типа double (результатом будет объект класса)
	sterling operator/ (double n) const
	{
		return sterling(double(sterling(pounds, shillings, pences)) / n);
	}
};

int main() {
	setlocale(0, "");
	const int N = 1;
	int n = 0, zadanie;
	double chisl, znam, obsh = 0;
	char oper, da;
	cout << "Введите задание - ";
	cin >> zadanie;
	if (zadanie == 5) {
		class time time1(5, 59, 59); //create and initialze 
		class time time2(4, 30, 30); // two times 
		class time time3; //create another 
		time3 = time1 + time2; //add two times 
		cout << "\ntime3 = "; 
		time3.display(); //display result 
		cout << endl;
		++time3;
		cout << "\n(префиксная) - сложение - time3 = ";
		time3.display(); //display result
		--time3;
		--time3;
		cout << "\n(префиксная) - вычитание - time3 = ";
		time3.display(); //display result 
		time3++;
		time3++;
		cout << "\n(постфиксная) - сложение - time3 = ";
		time3.display(); //display result
		time3--;
		time3--;
		cout << "\n(постфиксная) - вычитание - time3 = ";
		time3.display(); //display result

		cout << endl; return 0;

	}
	else if (zadanie == 6) {
		class time time1(5, 59, 59); //create and initialze 
		class time time2(4, 30, 30); // two times 
		class time time3; //create another 
		time3 = time1 - time2; //add two times 
		cout << "\nВычитание - time3 = ";
		time3.display(); //display result

		time3 = time1 * time2; //add two times 
		cout << "\nУмножение - time3 = ";
		time3.display(); //display result
		cout << endl;

	}
	else if (zadanie == 7) {
		fraction drob_raz, drob_dva, drob_rezylt, drob_vixod(0,1); // для хранения обыкновенных дробей
		char slash = '/', oper;
		cout << "Для выхода из программы введите значение 0/1 для первой и для второй дробей.\n\n";
		do {
			drob_raz.get();
			cout << "Введите знак - ";
			cin >> oper;
			drob_dva.get();
			if (drob_raz == drob_vixod && drob_dva == drob_vixod) {
				cout << "Всё(";
				break;
		}

			switch (oper)
			{
			case '+':
				drob_rezylt = drob_raz + drob_dva; 
				drob_rezylt.display(); 
				break;
			case '-':
				drob_rezylt = drob_raz - drob_dva; 
				drob_rezylt.display(); 
				break;
			case '*':
				drob_rezylt = drob_raz * drob_dva; 
				drob_rezylt.display(); 
				break;
			case '/':
				drob_rezylt = drob_raz / drob_dva; 
				drob_rezylt.display(); 
				break;
			default: 
				cout << "Введен неверный знак операции! Попробуйте еще." << endl;
			}
		} while (true); 

	}
	else if (zadanie == 8) {
		char da;
		bMoney m1, m2, mres; 
		long double ld, rezylt;
		do {
			cout << endl << "Введите первую денежную сумму - "; 
			m1.getmoney();
			cout << "Введите вторую денежную сумму - ";
			m2.getmoney();
			cout << "Введите число long double - "; 
			cin >> ld;
			mres = m1 + m2; 
			cout << endl << "Сложение -  "; 
			mres.putmoney(); 
			cout << endl;
			mres = m1 - m2; 
			cout << "Вычитание - "; 
			mres.putmoney(); 
			cout << endl;
			mres = m1 * ld;
			cout << "Умножение на число - "; 
			mres.putmoney(); 
			cout << endl;
			rezylt = m1 / m2; 
			cout << "Деление (первое на второе) - " << rezylt << endl;
			mres = m1 / ld;
			cout << "Деление (на число) - "; 
			mres.putmoney(); 
			cout << endl << "Хотите ввести другие данные? ";
			cin >> da; 
		} while (da != 'N');
	}
	else if (zadanie == 9) {
		int niz, vverh; // для верхней и нижней границ индекса массива

		cout << "Введите нижнюю границу индекса массива : "; cin >> niz;
		cout << "Введите верхнюю границу индекса массива: "; cin >> vverh;

		safearray sa1(niz, vverh);

		// задаем значения элементов
		for (int j = niz; j <= vverh; j++)
			// используем функцию слева от знака присваивания (=)
			sa1[j] = j * 10;

		// показываем элементы
		for (int j = niz; j <= vverh; j++)
		{
			// используем функцию справа от знака присваивания (=)
			int temp0 = sa1[j];
			cout << "Элемент " << j << " равен " << temp0 << endl;
		}

	}
	else if (zadanie == 10) {
		Polar p1, p2;
		cout << "Ввод полярных координат для первой точки.\n";
		p1.get();
		cout << "Ввод полярных координат для второй точки.\n";
		p2.get();
		p1 + p2;
		cout << endl;

	}
	else if (zadanie == 11) {
	sterling s1, s2, s; // денежные суммы в старой английской системе
	double n;           // число типа double
	cout << "1. "; s1.getSterling();
	cout << "2. "; s2.getSterling(); cout << endl;

	// покажем эти суммы в десятичных фунтах:
	cout << "1. В десятичных фунтах: " << fixed << setprecision(2) << double(s1) << endl;
	cout << "2. В десятичных фунтах: " << fixed << setprecision(2) << double(s2) << endl << endl;


	s = s1 + s2;
	cout << "Результат сложения этих сумм: "; 
	s.putSterling(); 
	cout << endl;
	s = s1 - s2;
	cout << "Разность этих сумм: "; 
	s.putSterling(); 
	cout << endl;
	s = s1 * 1.05;
	cout << "Произведение первой суммы и числа 1,05: "; 
	s.putSterling(); 
	cout << endl;
	n = s1 / s2;
	cout << "Частное от деления первой суммы на вторую: " << n << endl;
	s = s1 / 3.5;
	cout << "Частное от деления первой суммы на число 3,5: "; 
	s.putSterling();
	cout << endl;
	}
	else if (zadanie == 12) {
	char da;  // для ответа пользователя о продолжении ввода (д/н)
	int currency; // номер валюты
	bMoney sd;    // денежная сумма в долларах
	sterling sr;
	do {

		cout << "Введите номер валюты (1 — доллар, 2 — фунт): ";
		cin >> currency;

		if (currency == 1) // в долларах
		{
			sd.getmoney(); 
			//sr = sd;
			cout << "В старой английской системе: "; 
			sr.putSterling();
		}
		else if (currency == 2) // в фунтах, шиллингах и пенсах
		{
			sr.getSterling(); // запрашиваем сумму в фунтах, шиллингах и пенсах
			sd = sr;          // для преобразования используем
							  // конструктор с одним аргументом из класса bMoney
			cout << "В долларах: "; 
			sd.putmoney();
		}
		cout << "Закончили? "; 
		cin >> da; 
		cout << endl;
	} while (da != 'Y');

	}
}
